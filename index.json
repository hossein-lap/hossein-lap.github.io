[{"content":"Lua Syntax Invoking the interpreter with a Lua file name parameter begins execution of the file and continues until the script is finished. When the script is finished, the interpreter is no longer active.\nLet us write a simple Lua program. All Lua files will have extension .lua. So put the following source code in a test.lua file.\nprint(\u0026#34;test\u0026#34;) Assuming, lua environment is setup correctly, letâ€™s run the program using the following code:\n$ lua test.lua Result:\ntest Let\u0026rsquo;s try another way to execute a Lua program. Below is the modified test.lua file\n#!/usr/bin/env lua5.4 print(\u0026#34;test\u0026#34;) Now, try to run this program as follows:\n$ chmod +x test.lua $ ./test.lua Result:\ntest Lua also provides a mode called interactive mode. In this mode, you can type in instructions one after the other and get instant results. This can be invoked in the shell by using the lua -i or just the lua command. Once you type in this, press Enter and the interactive mode will be started as shown below.\n$ lua Lua 5.4.4 Copyright (C) 1994-2022 Lua.org, PUC-Rio \u0026gt; You can print something using the following statement:\nprint(\u0026#34;test\u0026#34;) Result:\n$ lua Lua 5.4.4 Copyright (C) 1994-2022 Lua.org, PUC-Rio \u0026gt; print(\u0026quot;test\u0026quot;) test \u0026gt; Tokens in Lua A Lua program consists of various tokens and a token is either a keyword, an identifier, a constant, a string literal, or a symbol. For example, the following Lua statement consists of three tokens:\nio.write(\u0026#34;Hello world, from \u0026#34;, _VERSION, \u0026#34;!\\n\u0026#34;) Result:\nHello world, from Lua 5.4! file (0x7fb1521ef5a0) ","permalink":"https://hossein-lap.github.io/posts/programming/script/lua/page/","summary":"This is a template for now.","title":"Lua"},{"content":"Go Syntax A Go file consists of the following parts:\nPackage declaration Import packages Functions Statements and expressions Example:\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello World!\u0026#34;) } Comments Go supports single-line or multi-line comments.\nSingle-line Comments // This is a comment Multi-line Comments /* * This is a Multi-line comment */ Variables Types int - stores integers (whole numbers), such as 123 or -123 float32 - stores floating point numbers, with decimals, such as 19.99 or -19.99 string - stores text, such as \u0026ldquo;Hello World\u0026rdquo;. String values are surrounded by double quotes bool - stores values with two states: true or false Declaring variables In Go, there are two ways to declare a variable:\nWith the var keyword:\nvar variablename type = value Note: You always have to specify either type or value (or both).\nWith the := sign:\nvariablename := value Note: In this case, the type of the variable is inferred from the value (means that the compiler decides the type of the variable, based on the value).\nNote: It is not possible to declare a variable using := without assigning a value to it.\nVariable Declaration With Initial Value var student1 string = \u0026#34;John\u0026#34; //type is string var student2 = \u0026#34;Jane\u0026#34; //type is inferred x := 2 //type is inferred Note: The variable types of student2 and x is inferred from their values.\nVariable Declaration Without Initial Value package main import (\u0026#34;fmt\u0026#34;) func main() { var a string var b int var c bool fmt.Println(a) fmt.Println(b) fmt.Println(c) } By running the code, we can see that they already have the default values of their respective types:\na is \u0026quot;\u0026quot; b is 0 c is false Value Assignment After Declaration func main() { var student1 string student1 = \u0026#34;John\u0026#34; fmt.Println(student1) } Difference Between var and := var := Can be used inside and outside of functions Can only be used inside functions Variable declaration and value assignment can be done separately Variable declaration and value assignment cannot be done separately (must be done in the same line) Multiple Variable Declaration var a, b, c, d int = 1, 3, 5, 7 Note: If you use the type keyword, it is only possible to declare one type of variable per line.\nIf the type keyword is not specified, you can declare different types of variables in the same line:\nvar a, b = 6, \u0026#34;Hello\u0026#34; c, d := 7, \u0026#34;World!\u0026#34; Variable Declaration in a Block Multiple variable declarations can also be grouped together into a block for greater readability:\nvar ( a int b int = 1 c string = \u0026#34;hello\u0026#34; ) Variable Naming Rules Go variable naming rules:\nA variable name must start with a letter or an underscore character (_) A variable name cannot start with a digit A variable name can only contain alpha-numeric characters and underscores (a-z, A-Z, 0-9, and _) Variable names are case-sensitive (age, Age and AGE are three different variables) There is no limit on the length of the variable name A variable name cannot contain spaces The variable name cannot be any Go keywords Constants If a variable should have a fixed value that cannot be changed, you can use the const keyword.\nconst CONSTNAME type = value Note: The value of a constant must be assigned when you declare it.\nconst PI = 3.14 Constant Rules Constant names follow the same naming rules as variables Constant names are usually written in uppercase letters (for easy identification and differentiation from variables) Constants can be declared both inside and outside of a function Constant Types There are two types of constants:\nTyped constants Untyped constants Multiple Constants Declaration Multiple constants can be grouped together into a block for readability:\nconst ( A int = 1 B = 3.14 C = \u0026#34;Hi!\u0026#34; ) Output Output Functions Go has three functions to output text:\nPrint() Println() Printf() The Print() Function The Print() function prints its arguments with their default format.\nIf we want to print the arguments in new lines, we need to use \\n. var i,j string = \u0026#34;Hello\u0026#34;,\u0026#34;World\u0026#34; fmt.Print(i, \u0026#34;\\n\u0026#34;) fmt.Print(j, \u0026#34;\\n\u0026#34;) Print() inserts a space between the arguments if neither are strings. The Println() Function The Println() function is similar to Print() with the difference that a whitespace is added between the arguments, and a newline is added at the end:\nvar i,j string = \u0026#34;Hello\u0026#34;,\u0026#34;World\u0026#34; fmt.Println(i, j) The Printf() Function The Printf() function first formats its argument based on the given formatting verb and then prints them.\nHere we will use two formatting verbs:\n%v is used to print the value of the arguments %T is used to print the type of the arguments var i string = \u0026#34;Hello\u0026#34; var j int = 15 fmt.Printf(\u0026#34;i has value: %v and type: %T\\n\u0026#34;, i, i) fmt.Printf(\u0026#34;j has value: %v and type: %T\u0026#34;, j, j) Formatting Verbs Go offers several formatting verbs that can be used with the Printf() function.\nGeneral Formatting Verbs The following verbs can be used with all data types:\nVerb Description %v Prints the value in the default format %#v Prints the value in Go-syntax format %T Prints the type of the value %% Prints the % sign Integer Formatting Verbs The following verbs can be used with the integer data type:\nVerb Description %b Base 2 %d Base 10 %+d Base 10 and always show sign %o Base 8 %O Base 8, with leading 0o %x Base 16, lowercase %X Base 16, uppercase %#x Base 16, with leading 0x %4d Pad with spaces (width 4, right justified) %-4d Pad with spaces (width 4, left justified) %04d Pad with zeroes (width 4) String Formatting Verbs The following verbs can be used with the string data type:\nVerb Description %s Prints the value as plain string %q Prints the value as a double-quoted string %8s Prints the value as plain string (width 8, right justified) %-8s Prints the value as plain string (width 8, left justified) %x Prints the value as hex dump of byte values % x Prints the value as hex dump with spaces Boolean Formatting Verbs The following verb can be used with the boolean data type:\nVerb Description %t Value of the boolean operator in true or false format (same as using %v) Float Formatting Verbs The following verbs can be used with the float data type:\nVerb Description %e Scientific notation with \u0026rsquo;e\u0026rsquo; as exponent %f Decimal point, no exponent %.2f Default width, precision 2 %6.2f Width 6, precision 2 %g Exponent as needed, only necessary digits Data Types Data type is an important concept in programming. Data type specifies the size and type of variable values.\nBasics Go is statically typed, meaning that once a variable type is defined, it can only store data of that type. It has three basic data types:\nbool: represents a boolean value and is either true or false Numeric: represents integer types, floating point values, and complex types string: represents a string value var a bool = true\t// Boolean var b int = 5\t// Integer var c float32 = 3.14 // Floating point number var d string = \u0026#34;Hi!\u0026#34; // String Boolean A boolean data type is declared with the bool keyword and can only take the values true or false.\nThe default value of a boolean data type is false.\nvar b1 bool = true // typed declaration with initial value var b2 = true // untyped declaration with initial value var b3 bool // typed declaration without initial value b4 := true // untyped declaration with initial value Note: Boolean values are mostly used for conditional testing.\nInteger Integer data types are used to store a whole number without decimals, like 35, -50, or 1345000.\nThe integer data type has two categories:\nSigned integers - can store both positive and negative values Unsigned integers - can only store non-negative values Tip: The default type for integer is int. If you do not specify a type, the type will be int.\nSigned Integers Signed integers, declared with one of the int keywords, can store both positive and negative values:\nvar x int = 500 var y int = -4500 Go has five keywords/types of signed integers:\nType Size Range int Depends on platform: 32 bits in 32 bit systems and 64 bit in 64 bit systems -2147483648 to 2147483647 in 32 bit systems and -9223372036854775808 to 9223372036854775807 in 64 bit systems int8 8 bits/1 byte -128 to 127 int16 16 bits/2 byte -32768 to 32767 int32 32 bits/4 byte -2147483648 to 2147483647 int64 64 bits/8 byte -9223372036854775808 to 9223372036854775807 Unsigned Integers Unsigned integers, declared with one of the uint keywords, can only store non-negative values:\nvar x uint = 500 var y uint = 4500 Go has five keywords/types of signed integers:\nType Size Range uint Depends on platform: 32 bits in 32 bit systems and 64 bit in 64 bit systems 0 to 4294967295 in 32 bit systems and 0 to 18446744073709551615 in 64 bit systems uint8 8 bits/1 byte 0 to 255 uint16 16 bits/2 byte 0 to 65535 uint32 32 bits/4 byte 0 to 4294967295 uint64 64 bits/8 byte 0 to 18446744073709551615 Float The float data types are used to store positive and negative numbers with a decimal point, like 35.3, -2.34, or 3597.34987.\nThe float data type has two keywords:\nType Size Range float32 32 bits -3.4e+38 to 3.4e+38 float64 64 bits -1.7e+308 to +1.7e+308 Tip: The default type for float is float64. If you do not specify a type, the type will be float64.\nThe float32 Keyword var x float32 = 123.78 var y float32 = 3.4e+38 The float64 Keyword The float64 data type can store a larger set of numbers than float32.\nvar x float64 = 1.7e+308 String The string data type is used to store a sequence of characters (text). String values must be surrounded by double quotes:\nvar txt1 string = \u0026#34;Hello!\u0026#34; var txt2 string txt3 := \u0026#34;World 1\u0026#34; Arrays Arrays are used to store multiple values of the same type in a single variable, instead of declaring separate variables for each value.\nDeclare an Array In Go, there are two ways to declare an array:\nWith the var keyword:\nvar array_name = [length]datatype{values} // length is defined var array_name = [...]datatype{values} // length is inferred With the := sign:\narray_name := [length]datatype{values} // length is defined array_name := [...]datatype{values} // length is inferred Note: The length specifies the number of elements to store in the array. In Go, arrays have a fixed length. The length of the array is either defined by a number or is inferred (means that the compiler decides the length of the array, based on the number of values).\nExample:\nvar arr1 = [3]int{1, 2, 3} var arr1 = [...]int{1, 2, 3} arr2 := [5]int{4, 5, 6, 7, 8} arr2 := [...]int{4, 5, 6, 7, 8} Access Elements of an Array You can access a specific array element by referring to the index number.\nIn Go, array indexes start at 0. That means that [0] is the first element, [1] is the second element, etc.\nprices := [3]int{10, 20, 30} fmt.Println(prices[0]) fmt.Println(prices[2]) Change Elements of an Array You can also change the value of a specific array element by referring to the index number.\nprices := [3]int{10, 20, 30} prices[2] = 50 Array Initialization If an array or one of its elements has not been initialized in the code, it is assigned the default value of its type.\nTip: The default value for int is 0 and the default value for string is \u0026quot;\u0026quot;.\narr1 := [5]int{} // not initialized arr2 := [5]int{1, 2} // partially initialized arr3 := [5]int{1, 2, 3, 4, 5} // fully initialized Initialize Only Specific Elements It is possible to initialize only specific elements in an array.\narr1 := [5]int{1:10, 2:40} The array above has 5 elements.\n1:10 means: assign 10 to array index 1 (second element). 2:40 means: assign 40 to array index 2 (third element). Find the Length of an Array The len() function is used to find the length of an array:\narr1 := [4]string{\u0026#34;Volvo\u0026#34;, \u0026#34;BMW\u0026#34;, \u0026#34;Ford\u0026#34;, \u0026#34;Mazda\u0026#34;} arr2 := [...]int{1, 2, 3, 4, 5, 6} fmt.Println(len(arr1)) fmt.Println(len(arr2)) Slices Slices are similar to arrays, but are more powerful and flexible.\nLike arrays, slices are also used to store multiple values of the same type in a single variable.\nHowever, unlike arrays, the length of a slice can grow and shrink as you see fit.\nCreate a Slice In Go, there are several ways to create a slice:\nUsing the []datatype{values} format Create a slice from an array Using the make() function []datatype{values} slice_name := []datatype{values} A common way of declaring a slice is like this:\nmyslice := []int{} The code above declares an empty slice of 0 length and 0 capacity.\nTo initialize the slice during declaration, use this:\nmyslice := []int{1, 2, 3} The code above declares a slice of integers of length 3 and also the capacity of 3.\nIn Go, there are two functions that can be used to return the length and capacity of a slice:\nlen() function - returns the length of the slice (the number of elements in the slice) cap() function - returns the capacity of the slice (the number of elements the slice can grow or shrink to) Example:\npackage main import (\u0026#34;fmt\u0026#34;) func main() { myslice1 := []int{} fmt.Println(len(myslice1)) fmt.Println(cap(myslice1)) fmt.Println(myslice1) myslice2 := []string{\u0026#34;Go\u0026#34;, \u0026#34;Slices\u0026#34;, \u0026#34;Are\u0026#34;, \u0026#34;Powerful\u0026#34;} fmt.Println(len(myslice2)) fmt.Println(cap(myslice2)) fmt.Println(myslice2) } Result:\n0 0 [] 4 4 [Go Slices Are Powerful] In the example above, we see that in the first slice (myslice1), the actual elements are not specified, so both the length and capacity of the slice will be zero. In the second slice (myslice2), the elements are specified, and both length and capacity is equal to the number of actual elements specified.\nCreate a Slice From an Array You can create a slice by slicing an array:\nvar myarray = [length]datatype{values} // An array myslice := myarray[start:end] // A slice made from the array arr1 := [6]int{10, 11, 12, 13, 14,15} myslice := arr1[2:4] fmt.Printf(\u0026#34;myslice = %v\\n\u0026#34;, myslice) fmt.Printf(\u0026#34;length = %d\\n\u0026#34;, len(myslice)) fmt.Printf(\u0026#34;capacity = %d\\n\u0026#34;, cap(myslice)) Result:\nmyslice = [12 13] length = 2 capacity = 4 In the example above myslice is a slice with length 2. It is made from arr1 which is an array with length 6.\nThe slice starts from the second element of the array which has value 12. The slice can grow to the end of the array. This means that the capacity of the slice is 4.\nIf myslice started from element 0, the slice capacity would be 6.\nCreate a Slice With The make() Function The make() function can also be used to create a slice.\nslice_name := make([]type, length, capacity) Note: If the capacity parameter is not defined, it will be equal to length\npackage main import (\u0026#34;fmt\u0026#34;) func main() { myslice1 := make([]int, 5, 10) fmt.Printf(\u0026#34;myslice1 = %v\\n\u0026#34;, myslice1) fmt.Printf(\u0026#34;length = %d\\n\u0026#34;, len(myslice1)) fmt.Printf(\u0026#34;capacity = %d\\n\u0026#34;, cap(myslice1)) // with omitted capacity myslice2 := make([]int, 5) fmt.Printf(\u0026#34;myslice2 = %v\\n\u0026#34;, myslice2) fmt.Printf(\u0026#34;length = %d\\n\u0026#34;, len(myslice2)) fmt.Printf(\u0026#34;capacity = %d\\n\u0026#34;, cap(myslice2)) } Result:\nmyslice1 = [0 0 0 0 0] length = 5 capacity = 10 myslice2 = [0 0 0 0 0] length = 5 capacity = 5 Access, Change, Append and Copy Slices Access Elements of a Slice You can access a specific slice element by referring to the index number.\nIn Go, indexes start at 0. That means that [0] is the first element, [1] is the second element, etc.\nprices := []int{10, 20, 30} fmt.Println(prices[0]) fmt.Println(prices[2]) Change Elements of a Slice You can also change a specific slice element by referring to the index number.\nprices := []int{10, 20, 30} prices[2] = 50 Append Elements To a Slice You can append elements to the end of a slice using the append() function:\nslice_name = append(slice_name, element1, element2, ...) myslice1 := []int{1, 2, 3, 4, 5, 6} fmt.Printf(\u0026#34;myslice1 = %v\\n\u0026#34;, myslice1) fmt.Printf(\u0026#34;length = %d\\n\u0026#34;, len(myslice1)) fmt.Printf(\u0026#34;capacity = %d\\n\u0026#34;, cap(myslice1)) myslice1 = append(myslice1, 20, 21) fmt.Printf(\u0026#34;myslice1 = %v\\n\u0026#34;, myslice1) fmt.Printf(\u0026#34;length = %d\\n\u0026#34;, len(myslice1)) fmt.Printf(\u0026#34;capacity = %d\\n\u0026#34;, cap(myslice1)) Append One Slice To Another Slice To append all the elements of one slice to another slice, use the append() function:\nslice3 = append(slice1, slice2...) Note: The \u0026lsquo;...\u0026rsquo; after slice2 is necessary when appending the elements of one slice to another.\nmyslice1 := []int{1, 2, 3} myslice2 := []int{4, 5, 6} myslice3 := append(myslice1, myslice2...) Change The Length of a Slice Unlike arrays, it is possible to change the length of a slice.\narr1 := [6]int{9, 10, 11, 12, 13, 14} // An array myslice1 := arr1[1:5] // Slice array fmt.Printf(\u0026#34;myslice1 = %v\\n\u0026#34;, myslice1) fmt.Printf(\u0026#34;length = %d\\n\u0026#34;, len(myslice1)) fmt.Printf(\u0026#34;capacity = %d\\n\u0026#34;, cap(myslice1)) /* Change length by re-slicing the array */ myslice1 = arr1[1:3] fmt.Printf(\u0026#34;myslice1 = %v\\n\u0026#34;, myslice1) fmt.Printf(\u0026#34;length = %d\\n\u0026#34;, len(myslice1)) fmt.Printf(\u0026#34;capacity = %d\\n\u0026#34;, cap(myslice1)) /* Change length by appending items */ myslice1 = append(myslice1, 20, 21, 22, 23) fmt.Printf(\u0026#34;myslice1 = %v\\n\u0026#34;, myslice1) fmt.Printf(\u0026#34;length = %d\\n\u0026#34;, len(myslice1)) fmt.Printf(\u0026#34;capacity = %d\\n\u0026#34;, cap(myslice1)) Memory Efficiency When using slices, Go loads all the underlying elements into the memory.\nIf the array is large and you need only a few elements, it is better to copy those elements using the copy() function.\nThe copy() function creates a new underlying array with only the required elements for the slice. This will reduce the memory used for the program.\ncopy(dest, src) The copy() function takes in two slices dest and src, and copies data from src to dest. It returns the number of elements copied.\nnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15} // Original slice fmt.Printf(\u0026#34;numbers = %v\\n\u0026#34;, numbers) fmt.Printf(\u0026#34;length = %d\\n\u0026#34;, len(numbers)) fmt.Printf(\u0026#34;capacity = %d\\n\u0026#34;, cap(numbers)) // Create copy with only needed numbers neededNumbers := numbers[:len(numbers)-10] numbersCopy := make([]int, len(neededNumbers)) copy(numbersCopy, neededNumbers) fmt.Printf(\u0026#34;numbersCopy = %v\\n\u0026#34;, numbersCopy) fmt.Printf(\u0026#34;length = %d\\n\u0026#34;, len(numbersCopy)) fmt.Printf(\u0026#34;capacity = %d\\n\u0026#34;, cap(numbersCopy)) Result:\nnumbers = [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] length = 15 capacity = 15 numbersCopy = [1 2 3 4 5] length = 5 capacity = 5 The capacity of the new slice is now less than the capacity of the original slice because the new underlying array is smaller.\nOperators Operators are used to perform operations on variables and values.\nThe + operator adds together two values, like in the example below:\nvar a = 15 + 25 Although the + operator is often used to add together two values, it can also be used to add together a variable and a value, or a variable and another variable:\nvar ( sum1 = 100 + 50 // 150 (100 + 50) sum2 = sum1 + 250 // 400 (150 + 250) sum3 = sum2 + sum2 // 800 (400 + 400) ) Go divides the operators into the following groups:\nArithmetic operators Assignment operators Comparison operators Logical operators Bitwise operators Arithmetic Operators Arithmetic operators are used to perform common mathematical operations.\nOperator Name Description Example + Addition Adds together two values x + y - Subtraction Subtracts one value from another x - y * Multiplication Multiplies two values x * y / Division Divides one value by another x / y % Modulus Returns the division remainder x % y ++ Increment Increases the value of a variable by 1 x++ -- Decrement Decreases the value of a variable by 1 x-- Assignment Operators Assignment operators are used to assign values to variables.\nIn the example below, we use the assignment operator (=) to assign the value 10 to a variable called x:\nvar x = 10 The addition assignment operator (+=) adds a value to a variable:\nvar x = 10 x +=5 A list of all assignment operators:\nOperator Example Same As = x = 5 x = 5 += x += 3 x = x + 3 -= x -= 3 x = x - 3 *= x *= 3 x = x * 3 /= x /= 3 x = x / 3 %= x %= 3 x = x % 3 \u0026amp;= x \u0026amp;= 3 x = x \u0026amp; 3 ` =` `x ^= x ^= 3 x = x ^ 3 \u0026gt;\u0026gt;= x \u0026gt;\u0026gt;= 3 x = x \u0026gt;\u0026gt; 3 \u0026lt;\u0026lt;= x \u0026lt;\u0026lt;= 3 x = x \u0026lt;\u0026lt; 3 Comparison Operators Comparison operators are used to compare two values.\nNote: The return value of a comparison is either true (1) or false (0)\nIn the following example, we use the greater than operator (\u0026gt;) to find out if 5 is greater than 3:\nvar x = 5 var y = 3 fmt.Println(x \u0026gt; y) // returns 1 (true) because 5 is greater than 3 A list of all comparison operators:\nOperator Name Example == Equal to x == y != Not equal x != y \u0026gt; Greater than x \u0026gt; y \u0026lt; Less than x \u0026lt; y \u0026gt;= Greater than or equal to x \u0026gt;= y \u0026lt;= Less than or equal to x \u0026lt;= y Logical Operators Logical operators are used to determine the logic between variables or values:\nOperator Name Description Example \u0026amp;\u0026amp; Logical and Returns true if both statements are true x \u0026lt; 5 \u0026amp;\u0026amp; x \u0026lt; 10 ` ` Logical or ! Logical not Reverse the result, returns false if the result is true !(x \u0026lt; 5 \u0026amp;\u0026amp; x \u0026lt; 10) Bitwise Operators Bitwise operators are used on (binary) numbers:\nOperator Name Description Example \u0026amp; AND Sets each bit to 1 if both bits are 1 x \u0026amp; y ` ` OR Sets each bit to 1 if one of two bits is 1 ^ XOR Sets each bit to 1 if only one of two bits is 1 x ^ b \u0026lt;\u0026lt; Zero fill left shift Shift left by pushing zeros in from the right x \u0026lt;\u0026lt; 2 \u0026gt;\u0026gt; Signed right shift Shift right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off x \u0026gt;\u0026gt; 2 Conditions Conditional statements are used to perform different actions based on different conditions.\nA condition can be either true or false.\nGo supports the usual comparison operators from mathematics:\nLess than \u0026lt; Less than or equal \u0026lt;= Greater than \u0026gt; Greater than or equal \u0026gt;= Equal to == Not equal to != Additionally, Go supports the usual logical operators:\nLogical AND \u0026amp;\u0026amp; Logical OR || Logical NOT ! You can use these operators or their combinations to create conditions for different decisions.\nExample x \u0026gt; y x != y (x \u0026gt; y) \u0026amp;\u0026amp; (y \u0026gt; z) `(x == y) Go has the following conditional statements:\nif - specify a block of code to be executed, if a specified condition is true else - specify a block of code to be executed, if the same condition is false else if - specify a new condition to test, if the first condition is false switch - specify many alternative blocks of code to be executed if Statement Use the if statement to specify a block of Go code to be executed if a condition is true.\nif condition { /* * code to be executed if condition is true */ } Note: if is in lowercase letters. Uppercase letters (If or IF) will generate an error.\nif 20 \u0026gt; 18 { fmt.Println(\u0026#34;20 is greater than 18\u0026#34;) } x:= 20 y:= 18 if x \u0026gt; y { fmt.Println(\u0026#34;x is greater than y\u0026#34;) } if else Statement else Statement Use the else statement to specify a block of code to be executed if the condition is false.\nif condition { // code to be executed if condition is true } else { // code to be executed if condition is false } time := 20 if (time \u0026lt; 18) { fmt.Println(\u0026#34;Good day.\u0026#34;) } else { fmt.Println(\u0026#34;Good evening.\u0026#34;) } Note: The brackets in the else statement should be like } else {\nif (temperature \u0026gt; 15) { fmt.Println(\u0026#34;It is warm out there.\u0026#34;) } /* this raises an error */ else { fmt.Println(\u0026#34;It is cold out there.\u0026#34;) } else if Statement Use the else if statement to specify a new condition if the first condition is false.\nif condition1 { /* * code to be executed if condition1 is true */ } else if condition2 { /* * code to be executed if condition1 is false and * condition2 is true */ } else { /* * code to be executed if condition1 * and condition2 are both false */ } time := 22 if time \u0026lt; 10 { fmt.Println(\u0026#34;Good morning.\u0026#34;) } else if time \u0026lt; 20 { fmt.Println(\u0026#34;Good day.\u0026#34;) } else { fmt.Println(\u0026#34;Good evening.\u0026#34;) } Note: If condition1 and condition2 are BOTH true, only the code for condition1 are executed\nNested if Statement You can have if statements inside if statements, this is called a nested if.\nif condition1 { // code to be executed if condition1 is true if condition2 { /* * code to be executed if both condition1 * and condition2 are true */ } } num := 20 if num \u0026gt;= 10 { fmt.Println(\u0026#34;Num is more than 10.\u0026#34;) if num \u0026gt; 15 { fmt.Println(\u0026#34;Num is also more than 15.\u0026#34;) } } else { fmt.Println(\u0026#34;Num is less than 10.\u0026#34;) } switch Statement Use the switch statement to select one of many code blocks to be executed.\nThe switch statement in Go is similar to the ones in C. The difference is that it only runs the matched case so it does not need a break statement.\nSingle-Case switch Syntax switch expression { case x: // code block case y: ... default: // code block } This is how it works:\nThe expression is evaluated once The value of the switch expression is compared with the values of each case If there is a match, the associated block of code is executed The default keyword is optional. It specifies some code to run if there is no case match day := 3 switch day { case 1: fmt.Println(\u0026#34;One\u0026#34;) case 2: fmt.Println(\u0026#34;Two\u0026#34;) case 3: fmt.Println(\u0026#34;Three\u0026#34;) } default Keyword The default keyword specifies some code to run if there is no case match:\nday := 4 switch day { case 1: fmt.Println(\u0026#34;One\u0026#34;) case 2: fmt.Println(\u0026#34;Two\u0026#34;) case 3: fmt.Println(\u0026#34;Three\u0026#34;) default: fmt.Println(\u0026#34;Not in the [1-3] range\u0026#34;) } Note: All the case values should have the same type as the switch expression. Otherwise, the compiler will raise an error\nMulti-case switch Statement It is possible to have multiple values for each case in the switch statement:\nswitch expression { case x,y: // code block if expression is evaluated to x or y case v,w: // code block if expression is evaluated to v or w case z: ... default: // code block if expression is not found in any cases } day := 5 switch day { case 1, 3, 5: fmt.Println(\u0026#34;Odd weekday\u0026#34;) case 2, 4: fmt.Println(\u0026#34;Even weekday\u0026#34;) case 6, 7: fmt.Println(\u0026#34;Weekend\u0026#34;) default: fmt.Println(\u0026#34;Invalid day of day number\u0026#34;) } Loops For Loop The for loop loops through a block of code a specified number of times. And for loop is the only loop available in Go.\nLoops are handy if you want to run the same code over and over again, each time with a different value.\nEach execution of a loop is called an iteration.\nThe for loop can take up to three statements:\nfor statement1; statement2; statement3 { // code to be executed for each iteration } statement1 - Initializes the loop counter value. statement2 - Evaluated for each loop iteration. If it evaluates to TRUE, the loop continues. If it evaluates to FALSE, the loop ends. statement3 - Increases the loop counter value. Note: These statements don\u0026rsquo;t need to be present as loops arguments. However, they need to be present in the code in some form.\nfor i:= 0, i \u0026lt; 5, i++ { fmt.Println(i) } continue Statement The continue statement is used to skip one or more iterations in the loop. It then continues with the next iteration in the loop.\nfor i:=0; i \u0026lt; 5; i++ { if i == 3 { continue } fmt.Println(i) } break Statement The break statement is used to break/terminate the loop execution.\nfor i:=0; i \u0026lt; 5; i++ { if i == 3 { break } fmt.Println(i) } Note: continue and break are usually used with conditions.\nNested Loops It is possible to place a loop inside another loop.\nHere, the \u0026ldquo;inner loop\u0026rdquo; will be executed one time for each iteration of the \u0026ldquo;outer loop\u0026rdquo;:\nfor i:= 0, i \u0026lt; 5, i++ { for j:= 0, j \u0026lt; 5, j++ { fmt.Printf(\u0026#34;%d\\t\u0026#34;,i * j) } fmt.Println() } Range Keyword The range keyword is used to more easily iterate over an array, slice or map. It returns both the index and the value.\nThe range keyword is used like this:\nfor index, value := array|slice|map { // code to be executed for each iteration } This example uses range to iterate over an array and print both the indexes and the values at each (idx stores the index, val stores the value): fruits := [3]string{\u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;banana\u0026#34;} for idx, val := range fruits { fmt.Printf(\u0026#34;%v\\t%v\\n\u0026#34;, idx, val) } Tip: To only show the value or the index, you can omit the other output using an underscore (_).\nFunctions A function is a block of statements that can be used repeatedly in a program. A function will not execute automatically when a page loads. A function will be executed by a call to the function.\nCreate a Function To create (often referred to as declare) a function, do the following:\nUse the func keyword. Specify a name for the function, followed by parentheses (). Finally, add code that defines what the function should do, inside curly braces {}. func FunctionName() { // code to be executed } Call a Function Functions are not executed immediately. They are \u0026ldquo;saved for later use\u0026rdquo;, and will be executed when they are called.\nIn the example below, we create a function named \u0026ldquo;myMessage()\u0026rdquo;. The opening curly brace ( { ) indicates the beginning of the function code, and the closing curly brace ( } ) indicates the end of the function. The function outputs \u0026ldquo;I just got executed!\u0026rdquo;. To call the function, just write its name followed by two parentheses ():\nfunc myMessage() { fmt.Println(\u0026#34;I just got executed!\u0026#34;) } func main() { myMessage() // call the function } A function can be called multiple times. Naming Rules for Go Functions A function name must start with a letter A function name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ ) Function names are case-sensitive A function name cannot contain spaces If the function name consists of multiple words, techniques introduced for multi-word variable naming can be used Tip: Give the function a name that reflects what the function does!\nParameters and Arguments Information can be passed to functions as a parameter. Parameters act as variables inside the function.\nParameters and their types are specified after the function name, inside the parentheses. You can add as many parameters as you want, just separate them with a comma:\nfunc FunctionName(param1 type, param2 type, param3 type) { // code to be executed } Function With Parameter Example The following example has a function with one parameter (fname) of type string. When the familyName() function is called, we also pass along a name (e.g. Liam), and the name is used inside the function, which outputs several different first names, but an equal last name:\nfunc familyName(fname string) { fmt.Println(\u0026#34;Hello\u0026#34;, fname, \u0026#34;Refsnes\u0026#34;) } func main() { familyName(\u0026#34;Liam\u0026#34;) familyName(\u0026#34;Jenny\u0026#34;) familyName(\u0026#34;Anja\u0026#34;) } Result:\nHello Liam Refsnes Hello Jenny Refsnes Hello Anja Refsnes Note: When a parameter is passed to the function, it is called an argument. So, from the example above: fname is a parameter, while Liam, Jenny and Anja are arguments.\nMultiple Parameters Inside the function, you can add as many parameters as you want:\nfunc familyName(fname string, age int) { fmt.Println(\u0026#34;Hello\u0026#34;, age, \u0026#34;year old\u0026#34;, fname, \u0026#34;Refsnes\u0026#34;) } Note: When you are working with multiple parameters, the function call must have the same number of arguments as there are parameters, and the arguments must be passed in the same order.\nFunction Returns Values If you want the function to return a value, you need to define the data type of the return value (such as int, string, etc), and also use the return keyword inside the function:\nfunc FunctionName(param1 type, param2 type) type { // code to be executed return output } func myFunction(x int, y int) int { return x + y } func main() { fmt.Println(myFunction(1, 2)) } In Go, you can name the return values of a function.\nHere, we name the return value as result (of type int), and return the value with a naked return (means that we use the return statement without specifying the variable name):\nfunc myFunction(x int, y int) (result int) { result = x + y return } func main() { fmt.Println(myFunction(1, 2)) } The example above can also be written like this. Here, the return statement specifies the variable name:\nfunc myFunction(x int, y int) (result int) { result = x + y return result } func main() { fmt.Println(myFunction(1, 2)) } Store the Return Value in a Variable You can also store the return value in a variable, like this:\nfunc myFunction(x int, y int) (result int) { result = x + y return } func main() { total := myFunction(1, 2) fmt.Println(total) } Multiple Return Values Go functions can also return multiple values.\nfunc myFunction(x int, y string) (result int, txt1 string) { result = x + x txt1 = y + \u0026#34; World!\u0026#34; return } func main() { fmt.Println(myFunction(5, \u0026#34;Hello\u0026#34;)) } If we (for some reason) do not want to use some of the returned values, we can add an underscore (_) to omit this value.\nfunc myFunction(x int, y string) (result int, txt1 string) { result = x + x txt1 = y + \u0026#34; World!\u0026#34; return } func main() { _, b := myFunction(5, \u0026#34;Hello\u0026#34;) fmt.Println(b) } Recursion Functions Go accepts recursion functions. A function is recursive if it calls itself and reaches a stop condition.\nIn the following example, testcount() is a function that calls itself. We use the x variable as the data, which increments with 1 (x + 1) every time we recurse. The recursion ends when the x variable equals to 11 (x == 11).\npackage main import (\u0026#34;fmt\u0026#34;) func testcount(x int) int { if x == 11 { return 0 } fmt.Println(x) return testcount(x + 1) } func main(){ testcount(1) } Recursion is a common mathematical and programming concept. This has the benefit of meaning that you can loop through data to reach a result.\nThe developer should be careful with recursion functions as it can be quite easy to slip into writing a function which never terminates, or one that uses excess amounts of memory or processor power. However, when written correctly recursion can be a very efficient and mathematically-elegant approach to programming.\nIn the following example, factorial_recursion() is a function that calls itself. We use the x variable as the data, which decrements (-1) every time we recurse. The recursion ends when the condition is not greater than 0 (i.e. when it is 0).\npackage main import (\u0026#34;fmt\u0026#34;) func factorial_recursion(x float64) (y float64) { if x \u0026gt; 0 { y = x * factorial_recursion(x-1) } else { y = 1 } return } func main() { fmt.Println(factorial_recursion(4)) } To a new developer it can take some time to work out how exactly this works, best way to find out is by testing and modifying it.\nStruct A struct (short for structure) is used to create a collection of members of different data types, into a single variable.\nWhile arrays are used to store multiple values of the same data type into a single variable, structs are used to store multiple values of different data types into a single variable.\nA struct can be useful for grouping data together to create records.\nDeclare a Struct To declare a structure in Go, use the type and struct keywords:\ntype struct_name struct { member1 datatype; member2 datatype; member3 datatype; ... } Here we declare a struct type Person with the following members: name, age, job and salary:\ntype Person struct { name string age int job string salary int } Tip: Notice that the struct members above have different data types. name and job is of type string, while age and salary is of type int.\nAccess Struct Members To access any member of a structure, use the dot operator (.) between the structure variable name and the structure member:\ntype Person struct { name string age int job string salary int } func main() { var pers1 Person var pers2 Person /* Pers1 specification */ pers1.name = \u0026#34;Hege\u0026#34; pers1.age = 45 pers1.job = \u0026#34;Teacher\u0026#34; pers1.salary = 6000 /* Pers2 specification */ pers2.name = \u0026#34;Cecilie\u0026#34; pers2.age = 24 pers2.job = \u0026#34;Marketing\u0026#34; pers2.salary = 4500 } Pass Struct as Function Arguments You can also pass a structure as a function argument, like this:\ntype Person struct { name string age int job string salary int } func main() { var pers1 Person /* Pers1 specification */ pers1.name = \u0026#34;Hege\u0026#34; pers1.age = 45 pers1.job = \u0026#34;Teacher\u0026#34; pers1.salary = 6000 /* Print Pers1 info by calling a function */ printPerson(pers1) } func printPerson(pers Person) { fmt.Println(\u0026#34;Name: \u0026#34;, pers.name) fmt.Println(\u0026#34;Age: \u0026#34;, pers.age) fmt.Println(\u0026#34;Job: \u0026#34;, pers.job) fmt.Println(\u0026#34;Salary: \u0026#34;, pers.salary) } Maps Maps are used to store data values in key:value pairs. Each element in a map is a key:value pair. A map is an unordered and changeable collection that does not allow duplicates.\nThe length of a map is the number of its elements. You can find it using the len() function. The default value of a map is nil. Maps hold references to an underlying hash table.\nGo has multiple ways for creating maps.\nCreating Maps Using var and := var a = map[KeyType]ValueType{key1:value1, key2:value2,...} b := map[KeyType]ValueType{key1:value1, key2:value2,...} This example shows how to create maps in Go. Notice the order in the code and in the output package main import (\u0026#34;fmt\u0026#34;) func main() { var a = map[string]string{\u0026#34;brand\u0026#34;: \u0026#34;Ford\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;Mustang\u0026#34;} b := map[string]int{\u0026#34;Oslo\u0026#34;: 1, \u0026#34;Bergen\u0026#34;: 2, \u0026#34;Trondheim\u0026#34;: 3} fmt.Printf(\u0026#34;a\\t%v\\n\u0026#34;, a) fmt.Printf(\u0026#34;b\\t%v\\n\u0026#34;, b) } Result:\na map[brand:Ford model:Mustang] b map[Bergen:2 Oslo:1 Trondheim:3] Note: The order of the map elements defined in the code is different from the way that they are stored. The data are stored in a way to have efficient data retrieval from the map.\nCreating Maps Using Using make() Function var a = make(map[KeyType]ValueType) b := make(map[KeyType]ValueType) func main() { var a = make(map[string]string) // The map is empty now a[\u0026#34;brand\u0026#34;] = \u0026#34;Ford\u0026#34; a[\u0026#34;model\u0026#34;] = \u0026#34;Mustang\u0026#34; a[\u0026#34;year\u0026#34;] = \u0026#34;1964\u0026#34; b := make(map[string]int) b[\u0026#34;Oslo\u0026#34;] = 1 b[\u0026#34;Bergen\u0026#34;] = 2 b[\u0026#34;Trondheim\u0026#34;] = 3 b[\u0026#34;Stavanger\u0026#34;] = 4 } Creating an Empty Map There are two ways to create an empty map. One is by using the make() function and the other is by using the following syntax.\nvar a map[KeyType]ValueType Note: The make() function is the right way to create an empty map. If you make an empty map in a different way and write to it, it will causes a runtime panic.\nfunc main() { var a = make(map[string]string) var b map[string]string fmt.Println(a == nil) fmt.Println(b == nil) } Result:\nfalse true Allowed Key Types The map key can be of any data type for which the equality operator (==) is defined. These include:\nBooleans Numbers Strings Arrays Pointers Structs Interfaces (as long as the dynamic type supports equality) Invalid key types are:\nSlices Maps Functions These types are invalid because the equality operator (==) is not defined for them.\nAllowed Value Types The map values can be any type.\nAccessing Map Elements You can access map elements by:\nvalue = map_name[key] var a = make(map[string]string) a[\u0026#34;brand\u0026#34;] = \u0026#34;Ford\u0026#34; a[\u0026#34;model\u0026#34;] = \u0026#34;Mustang\u0026#34; a[\u0026#34;year\u0026#34;] = \u0026#34;1964\u0026#34; fmt.Printf(a[\u0026#34;brand\u0026#34;]) Updating and Adding Map Elements Updating or adding an elements are done by:\nmap_name[key] = value var a = make(map[string]string) a[\u0026#34;brand\u0026#34;] = \u0026#34;Ford\u0026#34; a[\u0026#34;model\u0026#34;] = \u0026#34;Mustang\u0026#34; a[\u0026#34;year\u0026#34;] = \u0026#34;1964\u0026#34; fmt.Println(a) a[\u0026#34;year\u0026#34;] = \u0026#34;1970\u0026#34; // Updating an element a[\u0026#34;color\u0026#34;] = \u0026#34;red\u0026#34; // Adding an element fmt.Println(a) Remove Element from Map Removing elements is done using the delete() function.\ndelete(map_name, key) var a = make(map[string]string) a[\u0026#34;brand\u0026#34;] = \u0026#34;Ford\u0026#34; a[\u0026#34;model\u0026#34;] = \u0026#34;Mustang\u0026#34; a[\u0026#34;year\u0026#34;] = \u0026#34;1964\u0026#34; fmt.Println(a) delete(a,\u0026#34;year\u0026#34;) fmt.Println(a) Check For Specific Elements in a Map You can check if a certain key exists in a map using:\nval, ok :=map_name[key] If you only want to check the existence of a certain key, you can use the blank identifier (_) in place of val.\nfunc main() { var a = map[string]string{ \u0026#34;brand\u0026#34;: \u0026#34;Ford\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;Mustang\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;1964\u0026#34;, \u0026#34;day\u0026#34;:\u0026#34;\u0026#34;, } /* Checking for existing key and its value */ val1, ok1 := a[\u0026#34;brand\u0026#34;] /* Checking for non-existing key and its value */ val2, ok2 := a[\u0026#34;color\u0026#34;] /* Checking for existing key and its value */ val3, ok3 := a[\u0026#34;day\u0026#34;] /* Only checking for existing key and not its value */ _, ok4 := a[\u0026#34;model\u0026#34;] fmt.Println(val1, ok1) fmt.Println(val2, ok2) fmt.Println(val3, ok3) fmt.Println(ok4) } Result:\nFord true false true true Maps Are References Maps are references to hash tables.\nIf two map variables refer to the same hash table, changing the content of one variable affect the content of the other.\npackage main import (\u0026#34;fmt\u0026#34;) func main() { var a = map[string]string{ \u0026#34;brand\u0026#34;: \u0026#34;Ford\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;Mustang\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;1964\u0026#34;, } b := a fmt.Println(a) fmt.Println(b) b[\u0026#34;year\u0026#34;] = \u0026#34;1970\u0026#34; fmt.Println(\u0026#34;After change to b:\u0026#34;) fmt.Println(a) fmt.Println(b) } Result:\nmap[brand:Ford model:Mustang year:1964] map[brand:Ford model:Mustang year:1964] After change to b: map[brand:Ford model:Mustang year:1970] map[brand:Ford model:Mustang year:1970] Iterating Over Maps You can use range to iterate over maps.\nNote the order of the elements in the output.\npackage main import (\u0026#34;fmt\u0026#34;) func main() { a := map[string]int{\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3, \u0026#34;four\u0026#34;: 4} for k, v := range a { fmt.Printf(\u0026#34;%v : %v, \u0026#34;, k, v) } } Result:\none : 1, two : 2, three : 3, four : 4, Iterate Over Maps in a Specific Order Maps are unordered data structures. If you need to iterate over a map in a specific order, you must have a separate data structure that specifies that order.\na := map[string]int{\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3, \u0026#34;four\u0026#34;: 4} var b []string // defining the order b = append(b, \u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;) for k, v := range a { // loop with no order fmt.Printf(\u0026#34;%v : %v, \u0026#34;, k, v) } fmt.Println() for _, element := range b { // loop with the defined order fmt.Printf(\u0026#34;%v : %v, \u0026#34;, element, a[element]) } Source w3schools.com ","permalink":"https://hossein-lap.github.io/posts/programming/compile/go/page/","summary":"This is a template for now.","title":"Go"},{"content":"Use case Markdown is a universal document converter.\n","permalink":"https://hossein-lap.github.io/posts/tools/pandoc/page/","summary":"Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ut purus elit,\nvestibulum ut, placerat ac, adipiscing vitae, felis. Curabitur dictum gravida\nmauris.","title":"Pandoc"}]